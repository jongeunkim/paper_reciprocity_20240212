## This is the collection of useful functions
## Every function has no dependency to other files

# Julia v1.1.1
# CSV v.0.5.5
# DataFrames v0.18.3
# Glob v1.2.0

using CSV, DataFrames, Dates, DelimitedFiles, Formatting, Glob, Random, DataStructures, Graphs, Logging
import Statistics

# const OUTPUT_HEADER = ["datetime", "forest", "num_trees", "num_splitVars", "num_vars", "num_constrs", "bounded", "bounded_ratio", "lazylevel", "relax", "objval_LP", "objval_heur", "objval", "MIPGap", "MIPNodes", "runtime_LP", "runtime_heur", "runtime_formulate", "runtime"]
const EPSILON = 1e-09

# function df_sol_to_box(df_sol, df_forest)
#     df = filter(row -> row.treeid > 0 && row.sol > 0.5 && row.splitvar == 0, df_sol)

#     for row in eachrow(df)
#         box = get_rectangle_by_treeid_node_id(df_forest, treeid, nodeid; get_con_ind=false)

# end

function get_logfile_name(prefix)
    time = Dates.format(Dates.now(), "yyyy-mm-dd-HH-MM-SS")
    prefix * "_" * time * ".log"
end

function save_dict_to_csvs(dict, dir)
    for (k, v) in dict
        open(dir * k * ".csv", "w") do io
            writedlm(io, v, ',')
        end
    end
end

function save_dict_to_file(dict, filename)
    open(filename, "w") do io
        for (k, v) in dict
            writedlm(io, k, "\t")
            writedlm(io, v, "\n")
        end
    end
end

function get_forest_index(ptr_forest, treeid, nodeid)
    return ptr_forest[treeid] + nodeid - 1
end


# function add_parent_column_to_forest(forest, ptr_forest)
#     parent = zeros(Int, size(forest, 1))
#     nodeId = convert(Array{Int}, forest[:, 1])
#     lchild = convert(Array{Int}, forest[:, 2])
#     rchild = convert(Array{Int}, forest[:, 3])

#     for ptr in ptr_forest[1:end-1]
#         n = 1
#         while n > 0
#             if lchild[ptr + n - 1] > 0 && parent[ptr + lchild[ptr + n - 1] - 1] == 0
#                 parent[ptr + lchild[ptr + n - 1] - 1] = n
#                 n = lchild[ptr + n - 1]
#             elseif rchild[ptr + n - 1] > 0 && parent[ptr + rchild[ptr + n - 1] - 1] == 0
#                 parent[ptr + rchild[ptr + n - 1] - 1] = n
#                 n = rchild[ptr + n - 1]
#             else
#                 n = parent[ptr + n - 1]
#             end
#         end
#     end
    
#     forest = hcat(forest, parent)
#     forest
# end


function get_tree_from_forest(forest, ptr, tree_number)
    # Select rows correponding to tree_number
    tree = forest[ptr[tree_number]:ptr[tree_number + 1] - 1, :]
end


function get_pointers(table, column; unique_values=[])
    # Assume that array is sorted by column

    if length(unique_values) == 0
        unique_values = sort(unique(table[:, column]))
    end
    
    ptr = [1]
    for i in unique_values
        num_rows = size(table[table[:, column] .== i, :], 1)
        ptr = [ptr ptr[end] + num_rows]
    end
    
    ptr
end


function get_splits(split_nodes; verbose=0)
    splitVars = convert(Array{Int64}, sort(unique(split_nodes[:, 4])))
    print(verbose > 1 ? format("splitVars: {}\n", splitVars) : "")
    
    splits = sortslices(unique(split_nodes[:, 4:5], dims=1), dims=1)
    print(verbose > 1 ? format("number of unique splits: {} (total splits {})\n", size(splits, 1), size(split_nodes, 1)) : "")
    
    ptr = get_pointers(splits, 1, unique_values=splitVars)
    print(verbose > 1 ? format("ptr_splits: {}\n", ptr) : "")
    
    splitVars, splits, ptr
end


function get_split_index(splitVars, splits, ptr, var, val)
    i = findall(x -> x == var, splitVars)[1]
    splitVals = splits[ptr[i]:ptr[i + 1] - 1, 2]
    ind = findall(x -> x == val, splitVals)[1]
    ptr[i] + ind - 1
end


function empty_DataFrame_with_header(header)
    df = DataFrame()
    for c in header
        df[Symbol(c)] = []
    end
    df
end


function vcat_DataFrames(df1, df2)
    # Union column names from two dataframes
    col1 = [String(names(df1)[i]) for i = 1:length(names(df1))]
    col2 = [String(names(df2)[i]) for i = 1:length(names(df2))]
    col = union(col1, col2)

    # Add missing columns to df1 
    for c in setdiff(col, col1)
        df1[Symbol(c)] = missing
    end
    
    # Add missing columns to df2 
    for c in setdiff(col, col2)
        df2[Symbol(c)] = missing
    end

    # Return df which is generated by concatenating df1 and df2 
    vcat(df1, df2)
end


function record_output(file, output, header=OUTPUT_HEADER)
    # Initialize
    df = empty_DataFrame_with_header(header)
    
    # If there exsits a csv file, add output in the file
    if isfile(file)
        # Set old output in DataFrame format
        df_old = CSV.read(file)
        df = vcat_DataFrames(df, df_old)    
    end

    # Add new output as the last row
    df = vcat_DataFrames(df, DataFrame(output))
    
    # Save df as a csv file
    CSV.write(file, df)
end


function get_solution_X(sol_x, splitVars, splits, ptr_splits)
    solution_X = Dict()
    
    for (i, var) in Iterators.enumerate(splitVars)
        ind_first_one = nothing

        # Find the first j that has one
        # If sol_x[v, :] is achievable, we can use an one-line expression below:
        # ind_first_one = findfirst(x -> x >= 1 - EPSILON, vec(sol_x[v, :]))
        for j = 1:(ptr_splits[i + 1] - ptr_splits[i])
            if sol_x[i, j] > 1 - EPSILON
                ind_first_one = j
                break
            end
        end
        
        if isequal(ind_first_one, nothing)
            """ sol_x[v, :] = [0, 0, ..., 0] """
            val = (splits[ptr_splits[i + 1] - 1, 2], Inf)
        elseif ind_first_one == 1
            """ sol_x[v, :] = [1, 1, ..., 1] """
            val = (-Inf, splits[ptr_splits[i], 2])
        else 
            """ sol_x[v, :] = [0, 0, ..., 0, 1, 1, ..., 1] (j is the index of the first 1) """
            val = (splits[ptr_splits[i] + ind_first_one - 2, 2], splits[ptr_splits[i] + ind_first_one - 1, 2])
        end
        
        solution_X[var] = val
    end
    
    solution_X
end


function get_solution_Y(sol_y, num_trees, leaf_nodes, ptr_leaf_nodes; return_solution_y=false)
    solution_Y = Dict()
    solution_y = Dict()
    
    for i in range(1, stop=num_trees)
        for j = 1:(ptr_leaf_nodes[i + 1] - ptr_leaf_nodes[i])
            if sol_y[i, j] > 1 - EPSILON
                solution_Y[i] = Int(leaf_nodes[ptr_leaf_nodes[i] + j - 1, 1])
                solution_y[i] = j
                break
            end
        end
    end
    
    if return_solution_y
        solution_Y, solution_y
    else
        solution_Y
    end
end

function get_optbox(df_sol, df_forest, df_splits; splitval_type="splitval1")
    df_optleaves = filter(row -> row.treeid > 0 && row.sol > 0.5, df_sol)
    ptr_forest = get_pointers(df_forest, "treeid")

    optbox = SortedDict()
    for row in eachrow(df_optleaves)
        forest_index = get_forest_index(ptr_forest, row.treeid, row.nodeid)
        rec = get_rectangle(df_forest, forest_index)
        optbox = intersect_rectangles(optbox, rec)
    end

    if splitval_type == "splitval1"
        for (k, v) in optbox


            num_intervals = nrow(df_splits[df_splits.splitvar1 .== k, :]) + 1
            new_v = [-1,-1]
            for i in 1:2
                if v[i] == 0
                    new_v[i] = 0
                elseif v[i] == typemax(Int)
                    new_v[i] = num_intervals
                else
                    new_v[i] = df_splits[df_splits.varindex .== v[i], :].splitval1[1]
                end
            end
            optbox[k] = new_v
        end
    end

    optbox
end

function get_optbox_from_result_directory(dir)
    df_sol = DataFrame(CSV.File(dir * "df_sol.csv"))
    df_forest = DataFrame(CSV.File(dir * "df_forest.csv"))
    data = get_dataframes(df_forest)
    df_splits = data["df_splits"]
    # df_splits = DataFrame(CSV.File(dir * "df_splits.csv"))
    optimalbox = get_optbox(df_sol, df_forest, df_splits, splitval_type="default")
end




function get_interval(df_forest, i, splitvar1)
    lb = 0
    ub = typemax(Int)

    while i > 0
        if df_forest.parent[i] <= 0
            break
        end

        nodeid = df_forest.nodeid[i]
        p = i + df_forest.parent[i] - nodeid
        if df_forest.splitvar1[p] == splitvar1
            if ub == typemax(Int) && nodeid == df_forest.lchild[p]
                # ub = df_forest.varindex[p]
                ub = min(ub, df_forest.varindex[p])
            elseif lb == 0 && nodeid == df_forest.rchild[p]
                # lb = df_forest.varindex[p]
                lb = max(lb, df_forest.varindex[p])
            end
        end
        
        # if lb > 0 && ub < typemax(Int)
        #     break
        # end
        
        i = p
    end

    lb, ub
end

function get_rectangle(df_forest, i; get_con_ind=false)
    rec = Dict()
    con_ind = Dict()

    while i > 0
        if df_forest.parent[i] <= 0
            break
        end

        nodeid = df_forest.nodeid[i]
        p = i + df_forest.parent[i] - nodeid
        splitvar = df_forest.splitvar1[p]

        if splitvar in keys(rec)
            if nodeid == df_forest.lchild[p]
                if df_forest.varindex[p] < rec[splitvar][2]
                    rec[splitvar][2] = df_forest.varindex[p]
                    con_ind[splitvar] = i
                end
            else
                if df_forest.varindex[p] > rec[splitvar][1]
                    rec[splitvar][1] = df_forest.varindex[p]
                    con_ind[splitvar] = i
                end
            end
        else
            if nodeid == df_forest.lchild[p]
                rec[splitvar] = [0, df_forest.varindex[p]]
                con_ind[splitvar] = i
            else
                rec[splitvar] = [df_forest.varindex[p], typemax(Int)]
                con_ind[splitvar] = i
            end
        end
        i = p
    end

    if get_con_ind
        return rec, con_ind
    end
    
    rec
end

function get_rectangle_by_treeid_node_id(df_forest, treeid, nodeid; get_con_ind=false)
    ptr_forest = get_pointers(df_forest, "treeid")
    forest_index = get_forest_index(ptr_forest, treeid, nodeid)
    rec = get_rectangle(df_forest, forest_index, get_con_ind=get_con_ind)
end

function intersect_rectangles(rec1, rec2)
    rec = deepcopy(rec1)

    for (k, v) in rec2
        if k in keys(rec)
            rec[k] = [max(rec[k][1], rec2[k][1]), min(rec[k][2], rec2[k][2])]
        else
            rec[k] = rec2[k]
        end
    end
    
    rec
end

function intersect_boxes(boxes)
    @assert length(boxes) > 0
    length(boxes) == 1 && return deepcopy(boxes[1])

    box = deepcopy(boxes[1])
    for b in boxes[2:end]
        box = intersect_rectangles(box, b)
    end
    return box
end

function isempty_box(box)
    for (k, v) in box
        if v[1] >= v[2]
            return true
        end
    end
    return false
end

function isConflict_tworec(rec1, rec2)
    splitvars = intersect(keys(rec1), keys(rec2))

    for k in splitvars
        if rec1[k][2] <= rec2[k][1] || rec2[k][2] <= rec1[k][1]
            return true
        end
    end

    return false
end

function issubset_box(box_small, box_large)
    for v in keys(box_large)
        if !(v in keys(box_small))
            return false
        end

        if box_small[v][1] < box_large[v][1]
            return false
        end

        if box_small[v][2] > box_large[v][2]
            return false
        end
    end
    
    return true
end

function minimal_box_containing_boxes(boxes)
    minimal_box = deepcopy(boxes[1])
    # println(minimal_box)

    for box in boxes[2:end]
        to_be_deleted_keys = []
        for v in keys(minimal_box)
            if !(v in keys(box))
                push!(to_be_deleted_keys, v)
            else
                minimal_box[v] = [min(minimal_box[v][1], box[v][1]), max(minimal_box[v][2], box[v][2])]
                if minimal_box[v][2] >= Inf && minimal_box[v][1] <= -Inf
                    push!(to_be_deleted_keys, v)
                end
            end
            # println(minimal_box)
            # println(to_be_deleted_keys)
        end

        for v in to_be_deleted_keys
            pop!(minimal_box, v)
        end
    end

    return minimal_box
end

function minimal_interval_containing_boxes(boxes, splitvar1, lb_min, ub_max)
    if splitvar1 in keys(boxes[1])
        lb = boxes[1][splitvar1][1]
        ub = boxes[1][splitvar1][2]
    else
        return lb_min, ub_max
    end

    for box in boxes[2:end]
        if splitvar1 in keys(box)
            lb = min(lb, box[splitvar1][1])
            ub = max(ub, box[splitvar1][2])
            if ub - lb >= ub_max - lb_min
                return lb_min, ub_max
            end
        else
            return lb_min, ub_max
        end
    end

    return lb, ub
end


function df_lazy_misic2bounded(df_forest, df_lazy)
    for row in eachrow(df_lazy)
        row.lb, row.ub = get_interval(df_forest, row.con_ind, row.splitvar1)
    end
    df_lazy
end

function get_maxclq_cuts(df_forest, df_constr; must_include=Set(), maxcuts=typemax(Int))
    num_constr = nrow(df_constr)
    # if num_constr <= 1
    #     return df_constr[[:leaves, :lb, :ub]]
    # end

    ##### Collect rectangles
    rec = [get_rectangle(df_forest, r.con_ind) for r in eachrow(df_constr)]

    ##### Construct a graph
    g = simple_graph(num_constr, is_directed=false)
    for i = 1:num_constr
        for j = (i + 1):num_constr
            if isConflict_tworec(rec[i], rec[j])
                add_edge!(g, i, j)
            end
        end
    end

    ##### Construct df_maxclq
    df_maxclq = DataFrame()
    covered = Set()
    for clq in maximal_cliques(g)
        if !issubset(clq, covered) && issubset(must_include, clq)
            lb = minimum(df_constr[clq, "lb"])
            ub = maximum(df_constr[clq, "ub"])
            leaves = []
            for i in clq
                append!(leaves, df_constr[i, "leaves"])
            end

            push!(df_maxclq, Dict(:leaves => leaves, :lb => lb, :ub => ub), cols=:union)
            union!(covered, clq)

            if nrow(df_maxclq) >= maxcuts
                break
            end
        end
    end

    df_maxclq
end


function get_boxes_df_forest(df_forest, varname, valname, minvalue, maxvalue)
    @assert varname in names(df_forest)
    @assert valname in names(df_forest)

    ### Initialize boxes
    boxes = [Dict() for i = 1:nrow(df_forest)] 

    ### For a nonleaf node, compute a box of a child by intersecting the node's box and the split
    for i = 1:nrow(df_forest)
        ### If it is a leaf node, then continue
        if df_forest[i, "lchild"] == 0
            continue
        end

        ### lch, rch: df_forest indexes of lchild and rchild
        nodeid = df_forest[i, "nodeid"]
        lch = i - nodeid + df_forest[i, "lchild"]
        rch = i - nodeid + df_forest[i, "rchild"]

        ### split information of parent
        var = df_forest[i, varname]
        val = df_forest[i, valname]

        ### Update boxes of lchild and rchild
        boxes[lch] = intersect_rectangles(boxes[i], Dict(var => [minvalue, val]))
        boxes[rch] = intersect_rectangles(boxes[i], Dict(var => [val, maxvalue]))
    end

    boxes
end


function convert_box_format(box, col_to, df_vars)
    @assert col_to in ["splitval1", "varindex"]

    box_new = Dict()
    for (var, vals) in box
        lb = 0
        ub = typemax(Int)

        if vals[1] > -Inf
            df = filter(row -> row.splitvar == var && row.splitval == vals[1], df_vars)
            lb = df[1, col_to]
        end

        if vals[2] < Inf
            df = filter(row -> row.splitvar == var && row.splitval == vals[2], df_vars)
            ub = df[1, col_to]
        end

        box_new[var] = [lb, ub]
    end

    box_new
end

function get_num_nodes_with_positive_pred(df_forest)
    nrow(filter(row -> row.pred > 0, df_forest))
end

function remove_duplicate_boxes(boxes)
    """
    When a duplicate occurs, keep the one ahead 
    """

    if length(boxes) == 1
        return boxes
    end

    boxes = deepcopy(boxes)
    to_be_deleted_indexes = Set([1])
    while length(to_be_deleted_indexes) > 0
        to_be_deleted_indexes = []

        for i in 1:length(boxes), j in 1:length(boxes)
            if i < j && boxes[i] == boxes[j]
                push!(to_be_deleted_indexes, j)
            end
        end

        boxes = [box for (i, box) in enumerate(boxes) if !(i in to_be_deleted_indexes)]
    end

    boxes
end

function remove_overlapping_boxes(boxes; max_num_boxes=typemax(Int))
    """
    When a overlapping occurs, keep the one ahead 
    """

    if length(boxes) == 1
        return boxes
    end

    boxes = deepcopy(boxes)
    i = 1
    while i < length(boxes) && i <= max_num_boxes
        to_be_deleted_indexes = []

        for j in (i + 1):length(boxes)
            if !isempty_box(intersect_boxes([boxes[i], boxes[j]]))
                push!(to_be_deleted_indexes, j)
            end
        end

        boxes = [box for (k, box) in enumerate(boxes) if !(k in to_be_deleted_indexes)]
        i += 1
    end

    boxes[1:i - 1]
end
    

function open_global_logger(logfile; loglevel=nothing)
    ##### Open a logger
    io = open(logfile, "w+")
    logger = SimpleLogger(io, Logging.Info)
    if loglevel == "Debug"
        logger = SimpleLogger(io, Logging.Debug)
    end
    global_logger(logger)

    return io
end





function string_to_container(str)
    eval(Meta.parse(str))
end

function get_df_partition_for_treeid_maxdepth(df_forest, treeid, maxdepth)
    """
    Return the rows of df_forest which correspond to the partition of `treeid` and `maxdepth`.
    """
    df_tree = filter( row -> (row.treeid == treeid && row.depth == maxdepth) 
                            || (row.treeid == treeid && row.depth < maxdepth && row.lchild == 0), 
                            df_forest)
    df_tree
end

function get_objval(file)
    DataFrame(CSV.File(file))[end, "objval"]
end

function append_column(file, colname, defaultvalue, value)
    df = DataFrame(CSV.File(file))
    # if !(colname in names(df)) 
    df[:, colname] = defaultvalue .* ones(nrow(df))
    df[end, colname] = value
    CSV.write(file, df)
    # end
end

function compute_gap_closed(value, UB, LB)
    (UB-value) / (UB-LB)
end

function update_gap_closed(dir; lb_method="misic", ub_method="misic-LP")
    UB_dir = Glob.glob("$(dir)$(ub_method)/result.csv")
    if length(UB_dir) > 0
        UB = get_objval(UB_dir[1])
    else
        return
    end
    LB_dir = Glob.glob("$(dir)$(lb_method)/result.csv")
    if length(LB_dir) > 0
        LB = get_objval(LB_dir[1])
    else
        return
    end

    resultfiles = Glob.glob("$(dir)/**/result.csv")
    append!(resultfiles, Glob.glob("$(dir)/**/**/result.csv"))
    for file in resultfiles
        objval = get_objval(file)
        gapclosed = compute_gap_closed(objval, UB, LB)
        append_column(file, "gapclosed", -1.0, gapclosed)
    end
end
